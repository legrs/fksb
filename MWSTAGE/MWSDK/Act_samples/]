
#include <TWELITE>
#include <NWK_SIMPLE>
#include <BRD_APPTWELITE>
#include <string.h>
#include <cmath>

#define BNO_DEV 0x28
#define BNO_REG_A 0x08 //acceleration register adress(6)
#define BNO_REG_M 0x0E //magnetron register adress(6)
#define BNO_REG_G 0x14 //gyro(differential of pos) register adress(6)
#define BNO_REG_Q 0x20 //quaternion register adress(8byte)
#define BNO_REG_T 0x34 //templature register adress(1)
#define BNO_CALIB_STAT 0x35
#define BNO_OPR_MODE 0x3D
#define BNO_UNIT_SEL 0x3B
#define BNO_RST_PIN 10
#define ESC_PIN0 5
#define ESC_PIN1 19
#define ESC_PIN2 4
#define HOLD 4
#define BTN 8
#define IN 0 //A1Pinは番号0

#define MMIN 80
#define MNOR 200
#define MMAX 380 //3200
#define AMMIN 640 //実際に出力するpwm
#define AMNOR 3840
#define MMIND 1//1frameで，リカバー用に加えてもいいdpwm

#define APP_ID 0x1234abcd
#define CHANNEL 13
#define REC_LID 0x01
#define LID 0x00
#define DAT_LEN 37
#define PKT_LEN 18

void send(const uint8_t adr, const byte dat[PKT_LEN]);
void printByte(const byte buff[], const uint8_t len);
void printByte(const byte buff);
void majiKeisandekiru3();

class I2C{
    private:
        byte adr = 0x00;

    public:
        void setAdr(const byte _adr){
            adr = _adr;
        }
        bool write(byte REG, byte VAL){
            if(auto&& wrt = Wire.get_writer(adr)){
                wrt << REG;
                wrt << VAL;
            }else{
                return false;
            }
            return true;
        }
        bool set(byte REG){
            if(auto&& wrt = Wire.get_writer(adr)){
                wrt << REG;
            }else{
                return false;
            }
            return true;
        }
        bool read(byte val[], uint8_t len){
            if(auto&& rdr = Wire.get_reader(adr, len)){
                for(uint8_t i=0; i<len; i++){
                    rdr >> val[i];
                }
            }else{
                return false;
            }
            return true;
        }
        //bool setread(byte REG, byte val[], uint8_t len){
        //    if(set(REG))
        //        return read(val, len);
        //    return false;
        //}
        bool readByte(byte REG, byte val){
            if(set(REG)){
                if(auto&& rdr = Wire.get_reader(adr, 1)){
                    rdr >> val;
                }else{
                    return false;
                }
                return true;
            }
            return false;
        }
};
class Flash{
    public:
        uint32_t cAdr;
        void read(uint32_t adr, byte dat[], uint8_t len){
            if(auto&& trs = SPI.get_rwer()){
                trs << 0x03;
                trs << (byte)(adr >> 16);
                trs << (byte)(adr >> 8) ;
                trs << (byte)adr       ;
                delay(1);
                for(uint8_t i=0; i<4; i++){
                    trs << 0x00;
                    trs >> dat[i];
                }
                for(uint8_t i=0; i<len+4; i++){
                    trs << 0x00; //dummy byte( to generate clock)
                    trs >> dat[i];
                }
            }
            //cAdr += len;
        }
        bool isWriteOK(){
                if(auto&& trs = SPI.get_rwer()){
                    byte stat;
                    trs << 0x05;
                    trs >> stat;
                    if(!(stat&(1<<0)) && stat&(1<<1)){
                        return true;
                    }else{
                        return false;
                    }
                }
        }
        //WEL  !!  max 256 byte !!
        void write(uint32_t adr, byte dat[], uint8_t len, bool doWrite){ 
            if(doWrite){
                //WREN ( allow twelite to write)
                if(auto&& trs = SPI.get_rwer()){
                    trs << 0x06;
                }//write(PP)
                if(auto&& trs = SPI.get_rwer()){
                    if(isWriteOK()){
                        trs << 0x02;
                        trs << (byte)(adr >> 16);
                        trs << (byte)(adr >> 8) ;
                        trs << (byte)adr       ;
                        for(uint8_t i=0; i<len; i++){
                            trs << dat[i];
                        }
                    }
                }
                cAdr += len;
            }
        }
        void eraseAll(){
            //WREN ( allow twelite to write)
            if(auto&& trs = SPI.get_rwer()){
                trs << 0x06;
            }
            //CER 
            if(auto&& trs = SPI.get_rwer()){
                trs << 0xC7;
            }
            delay(3000);
            cAdr = 0;
        }
        void print(uint32_t adr, uint16_t len){
            if(auto&& trs = SPI.get_rwer()){
                byte dump;
                trs << 0x03;
                trs << (byte)(adr >> 16);
                trs << (byte)(adr >> 8) ;
                trs << (byte)adr       ;
                delay(1);
                for(uint8_t i=0; i<4; i++){
                    trs << 0x00;
                    trs >> dump;
                }
                for(uint16_t i=0; i<len+4; i++){
                    trs << 0x00; //dummy byte( to generate clock)
                    trs >> dump;
                    Serial.print(dump, HEX);
                    Serial.print(" ");
                }
                Serial.println("");
            }
        }
};
class Quat{
    public:
        float w;
        float x;
        float y;
        float z;
        constexpr Quat() : w(1),x(0),y(0),z(0){}
        Quat(float _w,float _x,float _y,float _z) : w(_w),x(_x),y(_y),z(_z){}
        friend Quat operator*(const Quat &q1 , const Quat &q2){
            return Quat(
                    -q1.x*q2.x - q1.y*q2.y - q1.z*q2.z + q1.w*q2.w,
                     q1.w*q2.x - q1.z*q2.y + q1.y*q2.z + q1.x*q2.w,
                     q1.z*q2.x + q1.w*q2.y - q1.x*q2.z + q1.y*q2.w,
                    -q1.y*q2.x + q1.x*q2.y + q1.w*q2.z + q1.z*q2.w
                    );
        }

        void setFromByte(const byte buffer[]){
            const float scale = (1.0 / (1 << 14));
            int16_t x1, y1, z1, w1;
            x1 = y1 = z1 = w1 = 0;
            w1 = (((uint16_t)buffer[1]) << 8) | ((uint16_t)buffer[0]);
            x1 = (((uint16_t)buffer[3]) << 8) | ((uint16_t)buffer[2]);
            y1 = (((uint16_t)buffer[5]) << 8) | ((uint16_t)buffer[4]);
            z1 = (((uint16_t)buffer[7]) << 8) | ((uint16_t)buffer[6]);
            w = w1 *  scale;
            x = x1 *  scale;
            y = y1 *  scale;
            z = z1 *  scale;
        }
        void print(){
            Serial << w << " "  << x << " " << y << " " << z << mwx::crlf;
        }
        Quat invert(){
            Quat q;
            q.w =  w;
            q.x = -x;
            q.y = -y;
            q.z = -z;
            return q;
        }

};
class Vec{
    public:
        float x;
        float y;
        float z;

        Vec() : x(0),y(0),z(0){}
        Vec(float _x,float _y,float _z) : x(_x),y(_y),z(_z){}
        // multiply
        friend Vec operator*(const Vec v , const float f){
            return Vec(v.x*f,v.y*f,v.z*f);
        }
        friend Vec operator/(const Vec v , const float f){
            return Vec(v.x/f,v.y/f,v.z/f);
        }
        // cross
        friend Vec operator%(const Vec v1 , const Vec v2){
            return Vec( 
                v1.y*v2.z - v1.z*v2.y,
                v1.z*v2.x - v1.x*v2.z,
                v1.x*v2.y - v1.y*v2.x
            );
        }
        // dot
        friend float operator*(const Vec v1 , const Vec v2){
            return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
        }

        void setFromByte(const byte buffer[], const uint8_t k){ //0: gyro, 1:acc, 2:mag
            float scale = 1.0;;
            switch(k){
                case 0:
                    scale = 900.0; // rad/s
                    break;
                case 1:
                    scale = 16.0; // uT
                    break;
                case 2:
                    scale = 100.0; // m/s^2
                    break;
                default:
                    break;
            }

            int16_t x1, y1, z1;
            x1 = y1 = z1 = 0;
            x1 = (((uint16_t)buffer[1]) << 8) | ((uint16_t)buffer[0]);
            y1 = (((uint16_t)buffer[3]) << 8) | ((uint16_t)buffer[2]);
            z1 = (((uint16_t)buffer[5]) << 8) | ((uint16_t)buffer[4]);
            x = x1 / scale;
            y = y1 / scale;
            z = z1 / scale;
        }
        void print(){
            Serial << x << " " << y << " " << z << mwx::crlf;
        }
        void clip(Vec thres){
            float fac[3] = {x/thres.x , y/thres.y , z/thres.z};
            float max = fac[0];
            float min = fac[0];
            if( max < fac[1] ){
                max = fac[1];
            }
            if( max < fac[2] ){
                max = fac[2];
            }
            if( fac[1] < min ){
                min = fac[1];
            }
            if( fac[2] < min ){
                min = fac[2];
            }

            if( abs(min) < abs(max) ){
                // clip on upper
                if( 1 < max ){
                    x /= max;
                    y /= max;
                    z /= max;
                }
            }else{
                if( min < -1 ){
                    x /= -min;
                    y /= -min;
                    z /= -min;
                }
            }
        }
        Vec rotate(Quat q){
            Quat q1(x,y,z,0);
            Quat q2 = q * q1 * q.invert();
            return Vec(q2.x,q2.y,q2.z);
        }
};
// set rotation speed
void setrs(const uint8_t num, const uint16_t val){ //num0,1,2 |-> Timer1,3,4   0 < val < 200
    /*
    if( MMAX < val ) val = MMAX;
    val += AMMIN;
    switch(num){
        case 0:
            Timer1.change_duty(val, 16384);
            break;
        case 1:
            Timer4.change_duty(val, 16384);
            break;
        case 2:
            Timer3.change_duty(val, 16384);
            break;
    }
    */
}
void makePacket(byte dat[], uint8_t &index, byte q[8], uint16_t mp[3], byte &flag1, byte &flag2, uint8_t &solar){
    dat[0] = index;
    dat[1] = flag1;
    dat[2] = flag2;
    for(uint8_t j=3; j<3+8; j++){
        dat[j] = q[j-3];
    }//3 ~ 10

    //11 12
    //13 14
    //15 16
    memcpy(&dat[11], &mp[0], 2);
    memcpy(&dat[13], &mp[1], 2);
    memcpy(&dat[15], &mp[2], 2);

    //// 17
    dat[17] = solar;
}

// benri
void printByte(const byte buff[], const uint8_t len){
    for(uint8_t i=0; i<len; i++){
        Serial.print(buff[i], HEX);
        Serial.print(" ");
    }
    Serial.println("");
}
void printByte(const byte buff){
    Serial.println(buff, HEX);
}

I2C bno;
Flash f;

const float bpmoi[3] = {1000,1000,1000};
const float wpmoi = 100;

uint8_t index;
uint8_t solar;
uint8_t temp; // temperature



byte flag1;
byte flag2;
byte buff[8];
uint16_t mp[3];
byte dat[DAT_LEN];

Quat ori; // orientation
Vec avel; // angular velocity = gyro
Vec acce;

/*** the setup procedure (called on boot) */
void setup() {
    pinMode(BNO_RST_PIN, OUTPUT);
    digitalWrite(BNO_RST_PIN, LOW);
    delay(10);
    digitalWrite(BNO_RST_PIN, HIGH);

    Serial << "--- program start ---" << crlf;

    index = 0;
    flag1 = 0b00000000;
    flag2 = 0b00000000;
    // mp[0] = ----
    

        /****** setup spi   ******/


    SPI.begin(0 // DIO19をチップセレクトとして使用
              , { 5000000UL // クロック周波数 
            , SPI_CONF::MSBFIRST
            , SPI_CONF::SPI_MODE0
    });
    delay(1000);

    if(auto&& trs = SPI.get_rwer()){

            // このへん要検討 -----------------------------------------------------------||

        byte deb;
        trs << 0x9F;
        delay(1);
        trs << 0x00;
        trs >> deb;
        trs << 0x00;
        trs >> deb;
        if(deb==0x9D){
            Serial << "flash memory : ok" << mwx::crlf;
        }else{
            Serial << "flash memory : failed!" << mwx::crlf;
        }
    }

    //f.eraseAll();    

        /****** setup i2c   ******/

    Wire.begin();  
    delay(500);

    // bno setup ( https://cdn-shop.adafruit.com/datasheets/BST_BNO055_DS000_12.pdf)
    bno.setAdr(BNO_DEV);
    if(bno.write(BNO_OPR_MODE, 0x08)){
        delay(20);
        // set units
        bno.write(0x3B, (0<<0)); 
        delay(10);
        bno.write(0x3B, (1<<1)); 
        delay(10);
        bno.write(0x3B, (0<<4)); 

        Serial << "bno : ok" << mwx::crlf;
    }else{
        Serial << "bno : failed!" << mwx::crlf;
        flag1 |= (1<<0);
    }

        /******  twelite setup ******/

    the_twelite
        << TWENET::appid(APP_ID)    // set application ID (identify network group)
        << TWENET::channel(CHANNEL) // set channel (pysical channel)
        << TWENET::rx_when_idle();  // open receive circuit (if not set, it can't listen packts from others)
    auto&& nwksmpl = the_twelite.network.use<NWK_SIMPLE>();
    nwksmpl << NWK_SIMPLE::logical_id(LID) // set Logical ID. (0xFE means a child device with no ID)
            << NWK_SIMPLE::repeat_max(3);   // can repeat a packet up to this times. (being kind of a router)
    the_twelite.begin(); // start twelite!
    delay(100);


    //////////////////////////    これより下debug    //////////////////////////

    // loop stop
    flag1 |= (1<<0);


    /*
    delay(500);

        f.cAdr = 0x000000;
        for(uint8_t i=0; i<8; i++){
            buff[i] = i;
            printByte(buff[i]);
        }
        f.write(f.cAdr, buff, 8, true);

    delay(500);

    f.eraseAll();    
        f.cAdr = 0x000000;
        buff[0] = 0x55;
        buff[1] = 0x56;
        buff[2] = 0x57;
        f.write(f.cAdr, buff, 3, true);
    delay(500);


        f.cAdr = 0x000000;
        f.read(f.cAdr, dat, 10);
        printByte(dat, 10);
        */
}

/*** the loop procedure (called every event) */
void loop() {
    // do run
    if(!(flag1&(1<<0))){

        if(f.cAdr > 0x07FFFF){
            f.cAdr = 0x000000;
            Serial << "------------------ memory full -----------------------" << crlf;
        }


        // calibration status
        bno.set(BNO_CALIB_STAT);
        bno.read(buff, 1);
        if(buff[0]&(1<<6)){
            Serial << "6" << crlf;
        }
        if(buff[0]&(1<<7)){
            Serial << "7" << crlf;
        }
        //Serial.println(buff[0], BIN);

        // write inedex
        buff[0] = index;
        f.write(f.cAdr, buff, 1, (bool)(flag1&(1<<1)));

        // acceralation
        bno.set(BNO_REG_A);
        bno.read(buff, 6);
        acce.setFromByte(buff,2);
        f.write(f.cAdr, buff, 6, (bool)(flag1&(1<<1)));

        // temperature
        bno.set(BNO_REG_T);
        bno.read(buff, 1);
        temp = buff[0];
        f.write(f.cAdr, buff, 1, (bool)(flag1&(1<<1)));

        // gyro
        bno.set(BNO_REG_G);
        bno.read(buff, 6);
        avel.setFromByte(buff,0);
        f.write(f.cAdr, buff, 6, (bool)(flag1&(1<<1)));

        // quaternion
        bno.set(BNO_REG_Q);
        bno.read(buff, 8);
        ori.setFromByte(buff);
        ori.print();
        f.write(f.cAdr, buff, 8, (bool)(flag1&(1<<1)));

        majiKeisandekiru3();

        // true on 0 4 8 ...
        if(!((index+4)%4)){
            makePacket(dat, index, buff, mp, flag1, flag2, solar);
            send(REC_LID, dat);
            index++;
        }
        index++;
    }else{
        //for(; f.cAdr <= 0x07FFFF; f.cAdr+=DAT_LEN){
        //    f.read(f.cAdr, dat, DAT_LEN);
        //    Serial << dat;
        //}


    }
    delay(100);
}

void majiKeisandekiru3(){

}
void send(const uint8_t adr, const byte dat[]) {
    if (auto&& pkt = the_twelite.network.use<NWK_SIMPLE>().prepare_tx_packet()) {
        pkt << tx_addr(adr)  // 0..0xFF (LID 0:parent, FE:child w/ no id, FF:LID broad cast), 0x8XXXXXXX (long address)
            << tx_retry(0x0) // set retry (0x3 send four times in total)
            << tx_packet_delay(0,5,20); // send packet w/ delay (send first packet with randomized delay from 100 to 200ms, repeat every 20ms)
        pack_bytes(pkt.get_payload() // set payload data objects.
            , make_pair(dat, PKT_LEN) // string should be paired with length explicitly.
        );
        pkt.transmit();
    }
}
void on_rx_packet(packet_rx& rx, bool_t &handled) {
    byte com;
    expand_bytes(rx.get_payload().begin(), rx.get_payload().end()
                , com       // 8bytes of msg
    );
    Serial << com << mwx::crlf;
    if(com & (1<<     0)){
    }else if(com&(1<< 1)){
        f.eraseAll();
    }else if(com&(1<< 2)){
    }else if(com&(1<< 3)){
    }else if(com&(1<< 4)){
    }else if(com&(1<< 5)){
    }
    /*
        0 :
        1 :
        2 :
        3 :
        4 :
        5 :
       */
    handled = true; //処理完了とする
}
/*
    bit flags
    flag1
        0 : stopping run? 1=stopping
        1 : do write? 1=write
        2 : do control?
        3 : 
        4 : 
        5 : 
        6 : 
        7 : 
        8 : 
    flag2   
        0 : is bno connection ok?
        1 : is bno calibrated?
        2 : is flash connection ok?
        3 : is launched?
        4 : is separated?
        5 : is landing?
        6 : 
        7 : 
        8 :

        operating modes ( 0x3D ) 0000<3:0>

          | accel | mag | gyro | relativeOri | absOri
    ------------------------------------------------------------
        0 |       |     |      |             |      
    ------------------------------------------------------------
        1 |   X   |     |      |             |      
    ------------------------------------------------------------
        2 |       |  X  |      |             |      
    ------------------------------------------------------------
        3 |       |     |  X   |             |      
    ------------------------------------------------------------
        4 |   X   |  X  |      |             |      
    ------------------------------------------------------------
        5 |   X   |     |  X   |             |      
    ------------------------------------------------------------
        6 |       |  X  |  X   |             |      
    ------------------------------------------------------------
        7 |   X   |  X  |  X   |             |      
    ------------------------------------------------------------
        8 |   X   |     |  X   |      X      |      
    ------------------------------------------------------------
        9 |   X   |  X  |      |             |   X  
    ------------------------------------------------------------
        a |   X   |  X  |      |      X      |      
    ------------------------------------------------------------
        b |   X   |  X  |  X   |             |   X  
    ------------------------------------------------------------
        c |   X   |  X  |  X   |             |   X  

*/
/*

    flash drive byte costruction

4*1024*1024/8bit/(30fps*5min*60sec) = 58.3 byte/frame

     0    index
     1    flag1
     2    flag2
     3-10 ori
    11-16 avel 
    17-22 acce
    23-28 mp
    29-34 mag
    35 solar
    36 temp

     
     
     
     
     

*/
/*

   やること
   - gyroとかの座標系を、しらべてほしいんだじぇ
   - flashの読み書きテスト
   - godotとR3でflash読むテスト
   - motoe まわせ


*/

